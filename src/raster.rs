// Подготовка массива для вывода
// Вход: размеры хоста, массив 2D точек, цвет
// Выход 
pub fn get_canvas() {

}

// Функция линейной интерполяции
// Вход: координаты начальной p0 и конечной p1 точек
// Выход: Массив промежуточных точек между p0 и p1
pub fn interpolate(p0: (i32, i32), p1: (i32, i32)) -> Vec<(i32, i32)> {
    let (x0, x1, y1, y0) = (p0.0, p1.0, p0.1, p1.1);
    if x1 == x2 { return vec![p0] }
    let mut v = vec![];
    let a = (y1 - y0) as f64 / (x1 - x0) as f64;
    let mut d = x0 as f64;
    for x in x0..=x1 {
        v.push((x, d as i32));
        d += a;
    }
    v
}

// Линия
pub fn line(p0: (i32, i32), p1: (i32, i32)) -> Vec<(i32, i32)>{
    let (x0, x1, y1, y0) = (p0.0, p1.0, p0.1, p1.1);
    let mut ys;
    if (x1 - x0).abs() > (y1 - y0).abs() {
        // прямая ближе к горизонтальной
        // проверяем, что x0 < x1; если нет, меняем местами
        if x0 > x1 { (x0, x1) = (x1, x0); }
        ys = interpolate((x0, y0), (x1, y1));
    } else {
        // прямая ближе к вертикальной
        // проверяем, что y0 < y1; если нет, меняем местами
        if y0 > y1 { (y0, y1) = (y1, y0); }
        ys = interpolate((y0, x0), (y1, x1));
    }
    ys
}

